############################################################################################################
## Goal: Crop the WRF Preprocessing System (WPS) output files to the region of interest (the portion of the 
## East Troublesome Fire east of the Continental Divide) to summarize the winds each hour for the a. Control
## and b. Experiment conditions. In Part 1 (figure_S02_wind_region.R), we found a domain that represents
## a 2-km buffer around the eastern portion of the East Troublesome Fire that crossed the Continental Divide.
## Here, we take the weather outputs from WPS (which include preprocessed HRRR weather data) and summarize 
## to create Figure 3 (stored in the figures directory).
##
## To run this file, please make sure your working directory is the East_Troublesome_Fire directory.
##
############################################################################################################

library(dplyr)
library(raster)
library(ncdf4)
library(sf)
library(ggplot2)
library(stringr)

## Set variables

# This is the directory where we have met_em*.nc files that are generated by
# the WRF Preprocessing System (WPS) using the High Resolution Rapid Refresh
# weather variables and LANDFIRE data
met_dir <- "wps_outputs/control"

# Read in the wind region shapefile created in figure_S02_wind_region.R and
# shown in Figure S2
wind_region <- st_read("data/wind_region.shp")

# Read in the eastern portion of the East Troublesome Fire (east of the
# Continental Divide)
fire_east <- st_read("data/fire_east.shp")

# Collect the bounding box from the domain extent
bb_crop <- st_bbox(wind_region)

# Create a raster extent object from this extent
ext <- extent(bb_crop)

# Create domains 01 and 02 for plotting and assigning the extent of the WPS
# output files. Note, that the met_em*.nc files for domain 02 have a domain 
# consistent with domain 02 described below. We need to assign this extent to the
# output files to crop them to the wind region from Figure S2.

# This PROJ string is created within WRF at the center coordinates of your region
# of interest
proj_string <- "+proj=lcc +lat_1=40.34917 +lat_2=40.34917 +lon_0=-105.6476" 

# Create center coordinates and than transform them into the custom WRF coordinate reference system
center_xy <- st_point(x = c(-105.6476, 40.34917)) %>% st_sfc(crs = 4326) %>% st_transform(crs = proj_string)

# These are the widths and heights of the nested domains specified for this study
domain01 <- st_bbox(center_xy) + c(-100000, -60000, 100000, 60000)
domain02 <- st_bbox(center_xy) + c(-25000, -15000, 25000, 15000)

# Collect the extent of the domains to create polygon objects for them
d01 <- extent(domain01)
d02 <- extent(domain02)

# Create polygons using the sf package for domain 01 and domain 02
d01_p1 <- st_point(x = c(d01@xmin, d01@ymin))
d01_p2 <- st_point(x = c(d01@xmin, d01@ymax))
d01_p3 <- st_point(x = c(d01@xmax, d01@ymax))
d01_p4 <- st_point(x = c(d01@xmax, d01@ymin))
d01_sf <- st_polygon(x = list(rbind(d01_p1, d01_p2, d01_p3, d01_p4, d01_p1))) %>%
  st_sfc(crs = proj_string)

d02_p1 <- st_point(x = c(d02@xmin, d02@ymin))
d02_p2 <- st_point(x = c(d02@xmin, d02@ymax))
d02_p3 <- st_point(x = c(d02@xmax, d02@ymax))
d02_p4 <- st_point(x = c(d02@xmax, d02@ymin))
d02_sf <- st_polygon(x = list(rbind(d02_p1, d02_p2, d02_p3, d02_p4, d02_p1))) %>%
  st_sfc(crs = proj_string)

# Write the domain shapefiles to our directory (domain 2 used in Figure 2)
st_write(d01_sf, "data/domain_01.shp", append = FALSE)
st_write(d02_sf, "data/domain_02.shp", append = FALSE)


# Collect the HRRR filenames
fnames <- list.files(met_dir, pattern = glob2rx("*nc"), full.names = TRUE)
fnames

# Use stringr to pull the dates from the filenames 
date_strings <- str_extract(fnames, pattern = "2020-10-[0-9]{2}_[0-9]{2}:00:00")

# Remove the underscore
date_strings <- gsub("_", " ", date_strings)

plot_dates <- as.Date(date_strings, "%Y-%m-%d %H:%M:%S")

plot_datetimes <- as.POSIXct(date_strings, format = "%Y-%m-%d %H:%M:%S", tz = "UTC")

# Number of time increments
N_times <- length(fnames)
mean_wind <- vector(length = N_times)
max_wind <- vector(length = N_times)
min_wind <- vector(length = N_times)

temp <- vector(length = N_times)
std_wind <- vector(length = N_times)

xy_list <- list()
for (i in 1:N_times){
  
  # Read in an HRRR netcdf file (translated from original grib2 to netcdf)
  # Let's try the met_em.d02*.nc data files instead
  
  nc <- nc_open(fnames[i])
  
  # List the names in your netcdf file
  names(nc$var)
  
  # Pull the U and V components of the winds for domain 02 (ignoring the
  # vertical wind)
  
  U <- ncvar_get(nc, "UU")
  V <- ncvar_get(nc, "VV")
  
  U <- U[,,1]
  V <- V[,,1]
  
  LAT_U <- ncvar_get(nc, "XLAT_U")
  LON_U <- ncvar_get(nc, "XLONG_U")
  
  LAT_V <- ncvar_get(nc, "XLAT_V")
  LON_V <- ncvar_get(nc, "XLONG_V")
  
  # Create an empty raster the same size as the array, U, to adjust array V
  # to the same coordinates
  Vp <- U*NA
  
  M <- nrow(Vp)
  N <- ncol(Vp)
  
  for (j in 1:M){
    for (k in 1:N){
      # The grids do not exactly match up for the U-component and V-components
      # of the wind, so we complete a nearest neighbor search to match the 
      # nearest elements of V to the coordinates of U 
      
      # Determine the nearest neighbor from the U lat,lon coordinates
      idx1 <- which.min(abs(LON_V[,1]-LON_U[j,1]))
      idx2 <- which.min(abs(LAT_V[1,]-LAT_U[1,k]))
      
      # This is the adjusted V array
      Vp[j,k] <- V[idx1, idx2]
  
    }
  }
  
  # Make sure they look about the same
  check1 <- raster(V)
  plot(check1)
  check2 <- raster(Vp)
  plot(check2)
  
  # Use our nearest-neighbor V (Vp) to generate the wind speed
  U2 <- U^2
  V2 <- Vp^2
  
  wind_speed <- sqrt(U2 + V2)
  
  # Transpose and flip our raster so that the x-axis and y-axis match
  # the orientation of domain 02
  wind_raster <- flip(t(raster(wind_speed)))
  
  # Set the CRS to the WPS-defined PROJ string
  crs(wind_raster) <- proj_string
  
  # Set the extent to that of domain 2
  extent(wind_raster) <- d02
  
  # Crop domain 02 to the wind region shown in Figure S2
  wind_zoom <- crop(wind_raster, bb_crop)
  
  # Convert this wind data to a data frame
  xy_df <- as.data.frame(wind_zoom, xy = TRUE) %>% mutate(dates = plot_dates[i], datetimes = plot_datetimes[i])

  # Store the wind data to the list
  xy_list[[i]] <- xy_df
  
  # Compute the mean, max, min, and standard deviation of the wind for reference
  mean_wind[i] <- mean(xy_df$layer, na.rm = TRUE)
  max_wind[i] <- max(xy_df$layer, na.rm = TRUE)
  min_wind[i] <- min(xy_df$layer, na.rm = TRUE)
  std_wind[i] <- sd(xy_df$layer, na.rm = TRUE)

}

# Row bind all the data frames for each time stamp together (each row for the same
# time stamp is a different pixel within our wind region of interest)
XY_df <- do.call(rbind.data.frame, xy_list) %>% dplyr::filter(datetimes >= as.POSIXct("2020-10-21 11:00:00", tz = "UTC"))

# Create a plot data frame in case we want to look at the mean and standard deviation
plot_df <- data.frame(x = 1:N_times, mean_wind = mean_wind, std_wind = std_wind)

# Add the dates to the data frame
plot_df$dates <- plot_dates
plot_df$datetimes <- plot_datetimes

# Create a custom color palette
my_pal <- palette.colors(palette = "Okabe-Ito", n = 9)[c(2,3,4,6,7)]

# Determine the experiment start date
experiment_start <- plot_df$datetimes[26]
experiment_start

# Transform the eastern portion of the East Troublesome Fire to the WPS 
# CRS
fire_east_t <- st_transform(fire_east, crs = proj_string)

# Create the indices for the time period of interest (we have more met_em*.nc files
# than our time period for the Control and Experiment simulations)
idx_plot <- seq(17, 89, by = 24)

# Generate the time stamps for the experiment run (turning the clock back 24 hours
# beginning on 2020-10-22 11:00:00 UTC); i.e., what once was called 2020-10-21 11:00:00 UTC
# will need to be repeated as 2020-10-22 11:00:00 UTC.
time_stamps <- unique(U_df$datetimes)
idx_start1 <- which(time_stamps == as.POSIXct("2020-10-21 11:00:00", tz = "UTC"))
idx_start2 <- which(time_stamps == as.POSIXct("2020-10-22 11:00:00", tz = "UTC"))

time_exp <- c(time_stamps[1:(idx_start2-1)], time_stamps[idx_start1:(length(time_stamps)-idx_start2 + idx_start1)])

time_df <- data.frame(time_stamps, time_exp)

XY_exp_list <- list()

# Create the repeated conditions for the experiment of one more windy day
for (i in 1:length(time_stamps)){
  time_temp <- time_stamps[i]
  time_exp_temp <- time_exp[i]

  temp_df <- dplyr::filter(XY_df, datetimes == time_exp_temp)
  temp_df$datetimes <- time_temp
  XY_exp_list[[i]] <- temp_df
}

# Row bind each hour together
XY_exp_df <- do.call(rbind.data.frame, XY_exp_list)

# Use a facet wrap plot to plot the horizontal wind
XY_facet1 <- mutate(XY_df, sim = "a. Control")
XY_facet2 <- mutate(XY_exp_df, sim = "b. Experiment")
XY_facet <- rbind.data.frame(XY_facet1, XY_facet2)

# Convert layer from m/s to km/hr
XY_facet$speed <- 3.6*(XY_facet$layer)

# Make the plot where the pixels from the region for each hour are represented as a vertical boxplot
# showing the spread of the winds for our region of interest at that time period
p_kph <- ggplot(data = XY_facet) + geom_rect(mapping = aes(xmin = "2020-10-22 11:00:00", xmax = "2020-10-25 03:00:00", ymin = -5, ymax = 80), fill = 'lightgray') +
  geom_boxplot(mapping = aes(x = as.factor(datetimes), y = speed, fill = as.factor(dates))) + scale_fill_discrete(name = "Observation\nDate", type = my_pal) +
  labs(x = "Simulation Date", y = "Wind speed (km/hr)") +
  facet_wrap(~sim, nrow = 2)  +
  geom_hline(yintercept = 0, color = 'black', linewidth = 1) +
  scale_x_discrete(breaks = as.factor(plot_datetimes[idx_plot])) +
  theme_bw()

# View the wind panel plot
p_kph

# Save the wind panel plot
ggsave("figures/figure_03_winds_by_sim_panel.png", plot = p_kph, dpi = 600, width = 8, height = 6, units = "in")

